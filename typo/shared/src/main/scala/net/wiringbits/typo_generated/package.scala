/** File has been automatically generated by `typo`.
  *
  * IF YOU CHANGE THIS FILE YOUR CHANGES WILL BE OVERWRITTEN.
  */
package net.wiringbits

package object typo_generated {
  implicit lazy val BigDecimalArrayToStatement: anorm.ToStatement[scala.Array[scala.math.BigDecimal]] =
    anorm.ToStatement[scala.Array[scala.math.BigDecimal]]((ps, index, v) =>
      ps.setArray(index, ps.getConnection.createArrayOf("numeric", v.map(v => v.bigDecimal)))
    )
  implicit lazy val BooleanArrayToStatement: anorm.ToStatement[scala.Array[scala.Boolean]] =
    anorm.ToStatement[scala.Array[scala.Boolean]]((ps, index, v) =>
      ps.setArray(index, ps.getConnection.createArrayOf("bool", v.map(v => v: java.lang.Boolean)))
    )
  implicit lazy val DoubleArrayToStatement: anorm.ToStatement[scala.Array[scala.Double]] =
    anorm.ToStatement[scala.Array[scala.Double]]((ps, index, v) =>
      ps.setArray(index, ps.getConnection.createArrayOf("float8", v.map(v => v: java.lang.Double)))
    )
  implicit lazy val FloatArrayToStatement: anorm.ToStatement[scala.Array[scala.Float]] =
    anorm.ToStatement[scala.Array[scala.Float]]((ps, index, v) =>
      ps.setArray(index, ps.getConnection.createArrayOf("float4", v.map(v => v: java.lang.Float)))
    )
  implicit lazy val IntArrayToStatement: anorm.ToStatement[scala.Array[scala.Int]] =
    anorm.ToStatement[scala.Array[scala.Int]]((ps, index, v) =>
      ps.setArray(index, ps.getConnection.createArrayOf("int4", v.map(v => v: java.lang.Integer)))
    )
  implicit lazy val LongArrayToStatement: anorm.ToStatement[scala.Array[scala.Long]] =
    anorm.ToStatement[scala.Array[scala.Long]]((ps, index, v) =>
      ps.setArray(index, ps.getConnection.createArrayOf("int8", v.map(v => v: java.lang.Long)))
    )
  implicit lazy val OffsetTimeReads: play.api.libs.json.Reads[java.time.OffsetTime] =
    play.api.libs.json.Reads.StringReads.flatMapResult { str =>
      try play.api.libs.json.JsSuccess(java.time.OffsetTime.parse(str))
      catch {
        case x: java.time.format.DateTimeParseException =>
          play.api.libs.json
            .JsError(s"must follow ${java.time.format.DateTimeFormatter.ISO_OFFSET_TIME}: ${x.getMessage}")
      }
    }
  implicit lazy val OffsetTimeWrites: play.api.libs.json.Writes[java.time.OffsetTime] =
    play.api.libs.json.Writes.StringWrites.contramap(_.toString)
  implicit lazy val ShortArrayToStatement: anorm.ToStatement[scala.Array[scala.Short]] =
    anorm.ToStatement[scala.Array[scala.Short]]((ps, index, v) =>
      ps.setArray(index, ps.getConnection.createArrayOf("int2", v.map(v => v: java.lang.Short)))
    )
  implicit def arrayParameterMetaData[T](implicit
      T: anorm.ParameterMetaData[T]
  ): anorm.ParameterMetaData[scala.Array[T]] = new anorm.ParameterMetaData[scala.Array[T]] {
    override def sqlType: java.lang.String = "_" + T.sqlType
    override def jdbcType: scala.Int = java.sql.Types.ARRAY
  }

  implicit def wrappedColumn[T <: net.wiringbits.webapp.common.models.WrappedString](implicit
      f: String => T
  ): anorm.Column[T] =
    anorm.Column.nonNull[T] { (value, _) =>
      value match {
        case string: String => Right(f(string))
        case _ => Left(anorm.TypeDoesNotMatch("Error parsing the email"))
      }
    }
  implicit def wrappedOrdering[T <: net.wiringbits.webapp.common.models.WrappedString]: scala.math.Ordering[T] =
    scala.math.Ordering.by(_.string)
  implicit def wrappedToStatement[T <: net.wiringbits.webapp.common.models.WrappedString]: anorm.ToStatement[T] =
    anorm.ToStatement[T]((s, index, v) => s.setObject(index, v.string))
  implicit def wrappedParameterMetaData[T <: net.wiringbits.webapp.common.models.WrappedString](implicit
      customSqlType: String = "VARCHAR"
  ): anorm.ParameterMetaData[T] = new anorm.ParameterMetaData[T] {
    override def sqlType: String = customSqlType

    override def jdbcType: Int = java.sql.Types.OTHER
  }
  implicit def idColumn[T <: net.wiringbits.common.models.id.Id](implicit f: String => T): anorm.Column[T] =
    anorm.Column.nonNull[T] { (value, _) =>
      value match {
        case string: String => Right(f(string))
        case _ => Left(anorm.TypeDoesNotMatch("Error parsing the email"))
      }
    }
  implicit def idOrdering[T <: net.wiringbits.common.models.id.Id]: Ordering[T] = Ordering.by(_.value)
  implicit def idToStatement[T <: net.wiringbits.common.models.id.Id]: anorm.ToStatement[T] =
    anorm.ToStatement[T]((s, index, v) => s.setObject(index, v.value))
  implicit def idParameterMetaData[T <: net.wiringbits.common.models.id.Id](implicit
      customSqlType: String
  ): anorm.ParameterMetaData[T] = new anorm.ParameterMetaData[T] {
    override def sqlType: String = customSqlType

    override def jdbcType: Int = java.sql.Types.OTHER
  }
  @SuppressWarnings(Array("org.wartremover.warts.Null"))
  private def timestamp[T](ts: java.sql.Timestamp)(f: java.sql.Timestamp => T): Either[anorm.SqlRequestError, T] =
    Right(
      if (ts == null) null.asInstanceOf[T] else f(ts)
    )
  private val timestamptzParser: java.time.format.DateTimeFormatter = new java.time.format.DateTimeFormatterBuilder()
    .appendPattern("yyyy-MM-dd HH:mm:ss")
    .appendFraction(java.time.temporal.ChronoField.MICRO_OF_SECOND, 0, 6, true)
    .appendPattern("X")
    .toFormatter
  implicit val columnToInstant: anorm.Column[net.wiringbits.common.models.InstantCustom] =
    anorm.Column.nonNull(instantValueTo(instantToInstantCustom))
  private def instantToInstantCustom(instant: java.time.Instant): net.wiringbits.common.models.InstantCustom =
    net.wiringbits.common.models.InstantCustom(instant)
  private def instantValueTo(
      epoch: java.time.Instant => net.wiringbits.common.models.InstantCustom
  )(value: Any, meta: anorm.MetaDataItem): Either[anorm.SqlRequestError, net.wiringbits.common.models.InstantCustom] = {
    value match {
      case date: java.time.LocalDateTime => Right(epoch(date.toInstant(java.time.ZoneOffset.UTC)))
      case ts: java.sql.Timestamp => timestamp(ts)(t => epoch(t.toInstant))
      case date: java.util.Date =>
        Right(epoch(java.time.Instant.ofEpochMilli(date.getTime)))
      case time: Long =>
        Right(epoch(java.time.Instant.ofEpochMilli(time)))
      case anorm.TimestampWrapper1(ts) => timestamp(ts)(t => epoch(t.toInstant))
      case anorm.TimestampWrapper2(ts) => timestamp(ts)(t => epoch(t.toInstant))
      case string: String =>
        scala.util.Try(
          net.wiringbits.common.models
            .InstantCustom(java.time.OffsetDateTime.parse(string, timestamptzParser).toInstant)
        ) match
          case scala.util.Failure(_) => Left(anorm.TypeDoesNotMatch("Error parsing the instant"))
          case scala.util.Success(value) => Right(value)
      case _ =>
        Left(anorm.TypeDoesNotMatch("Error parsing the instant"))
    }
  }
  implicit val instantCustomOrdering: Ordering[net.wiringbits.common.models.InstantCustom] = Ordering.by(_.value)
  implicit val instantCustomToStatement: anorm.ToStatement[net.wiringbits.common.models.InstantCustom] =
    anorm.ToStatement[net.wiringbits.common.models.InstantCustom]((s, index, v) => s.setObject(index, v.value.toString))
  implicit val instantParameterMetaData: anorm.ParameterMetaData[net.wiringbits.common.models.InstantCustom] =
    new anorm.ParameterMetaData[net.wiringbits.common.models.InstantCustom] {
      override def sqlType: String = "TIMESTAMPTZ"

      override def jdbcType: Int = java.sql.Types.TIMESTAMP_WITH_TIMEZONE
    }
  implicit def enumJobTypeColumn[T <: enumeratum.EnumEntry](implicit
      withNameInsensitiveOption: String => Option[T]
  ): anorm.Column[T] =
    anorm.Column.nonNull[T] { (value, _) =>
      value match {
        case string: String =>
          withNameInsensitiveOption(string) match
            case Some(value) => Right(value)
            case None => Left(anorm.TypeDoesNotMatch(s"Unknown enum: $string"))
        case _ => Left(anorm.TypeDoesNotMatch("Error parsing the enum"))
      }
    }
  implicit def enumOrdering[T <: enumeratum.EnumEntry]: scala.math.Ordering[T] =
    scala.math.Ordering.by(_.entryName)
  implicit def enumToStatement[T <: enumeratum.EnumEntry]: anorm.ToStatement[T] =
    anorm.ToStatement[T]((s, index, v) => s.setObject(index, v.entryName))
  implicit def enumParameterMetaData[T <: enumeratum.EnumEntry]: anorm.ParameterMetaData[T] =
    new anorm.ParameterMetaData[T] {
      override def sqlType: String = "TEXT"

      override def jdbcType: Int = java.sql.Types.VARCHAR
    }
}
